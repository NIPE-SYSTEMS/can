   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               	.global	__floatsisf
  10               	.global	__subsf3
  11               	.global	__mulsf3
  12               	.global	__ltsf2
  13               	.global	__gtsf2
  14               	.global	drive
  16               	drive:
  17               	.LFB7:
  18               		.file 1 "././motor.h"
   1:././motor.h   **** void drive(uint32_t steps, char leftDir, char rightDir) // leftDir[0=reverse,1=forward], rightDir[0
   2:././motor.h   **** {
  19               		.loc 1 2 0
  20               	.LVL0:
  21 0000 2F92      		push r2
  22               	.LCFI0:
  23 0002 3F92      		push r3
  24               	.LCFI1:
  25 0004 4F92      		push r4
  26               	.LCFI2:
  27 0006 5F92      		push r5
  28               	.LCFI3:
  29 0008 6F92      		push r6
  30               	.LCFI4:
  31 000a 7F92      		push r7
  32               	.LCFI5:
  33 000c 8F92      		push r8
  34               	.LCFI6:
  35 000e 9F92      		push r9
  36               	.LCFI7:
  37 0010 AF92      		push r10
  38               	.LCFI8:
  39 0012 BF92      		push r11
  40               	.LCFI9:
  41 0014 CF92      		push r12
  42               	.LCFI10:
  43 0016 DF92      		push r13
  44               	.LCFI11:
  45 0018 EF92      		push r14
  46               	.LCFI12:
  47 001a FF92      		push r15
  48               	.LCFI13:
  49 001c 0F93      		push r16
  50               	.LCFI14:
  51 001e 1F93      		push r17
  52               	.LCFI15:
  53 0020 CF93      		push r28
  54               	.LCFI16:
  55 0022 DF93      		push r29
  56               	.LCFI17:
  57               	/* prologue: function */
  58               	/* frame size = 0 */
  59               	/* stack size = 18 */
  60               	.L__stack_usage = 18
  61 0024 6B01      		movw r12,r22
  62 0026 7C01      		movw r14,r24
   3:././motor.h   **** 	if(leftDir == 0)
  63               		.loc 1 3 0
  64 0028 4111      		cpse r20,__zero_reg__
  65 002a 00C0      		rjmp .L2
   4:././motor.h   **** 		PORTD &= ~(1<<MOTOR_DIR_LEFT);
  66               		.loc 1 4 0
  67 002c 9198      		cbi 0x12,1
  68 002e 00C0      		rjmp .L3
  69               	.L2:
   5:././motor.h   **** 	else
   6:././motor.h   **** 		PORTD |= (1<<MOTOR_DIR_LEFT);
  70               		.loc 1 6 0
  71 0030 919A      		sbi 0x12,1
  72               	.L3:
   7:././motor.h   **** 	
   8:././motor.h   **** 	if(rightDir == 0)
  73               		.loc 1 8 0
  74 0032 2111      		cpse r18,__zero_reg__
  75 0034 00C0      		rjmp .L4
   9:././motor.h   **** 		PORTD |= (1<<MOTOR_DIR_RIGHT);
  76               		.loc 1 9 0
  77 0036 929A      		sbi 0x12,2
  78 0038 00C0      		rjmp .L5
  79               	.L4:
  10:././motor.h   **** 	else
  11:././motor.h   **** 		PORTD &= ~(1<<MOTOR_DIR_RIGHT);
  80               		.loc 1 11 0
  81 003a 9298      		cbi 0x12,2
  82               	.L5:
  12:././motor.h   **** 	
  13:././motor.h   **** 	if(steps <= 3000)
  83               		.loc 1 13 0
  84 003c 89EB      		ldi r24,-71
  85 003e C816      		cp r12,r24
  86 0040 8BE0      		ldi r24,11
  87 0042 D806      		cpc r13,r24
  88 0044 E104      		cpc r14,__zero_reg__
  89 0046 F104      		cpc r15,__zero_reg__
  90 0048 00F0      		brlo .+2
  91 004a 00C0      		rjmp .L33
  92               	.LBB57:
  14:././motor.h   **** 	{
  15:././motor.h   **** 		for(int i = 1; i <= (steps / 2); i+=1)
  93               		.loc 1 15 0
  94 004c F694      		lsr r15
  95 004e E794      		ror r14
  96 0050 D794      		ror r13
  97 0052 C794      		ror r12
  98 0054 01E0      		ldi r16,lo8(1)
  99 0056 10E0      		ldi r17,0
 100               	.LBB58:
  16:././motor.h   **** 		{
  17:././motor.h   **** 			PORTD |= (1<<MOTOR_CLOCK_LEFT) | (1<<MOTOR_CLOCK_RIGHT);
  18:././motor.h   **** 			for(int j = 0; j < 1000*(sqrt(i+1)-sqrt(i)); j++)
 101               		.loc 1 18 0
 102 0058 A12C      		mov r10,__zero_reg__
 103 005a B12C      		mov r11,__zero_reg__
 104 005c 00C0      		rjmp .L47
 105               	.LVL1:
 106               	.L13:
 107               	.LBE58:
  17:././motor.h   **** 			PORTD |= (1<<MOTOR_CLOCK_LEFT) | (1<<MOTOR_CLOCK_RIGHT);
 108               		.loc 1 17 0
 109 005e 82B3      		in r24,0x12
 110 0060 8861      		ori r24,lo8(24)
 111 0062 82BB      		out 0x12,r24
 112               	.LVL2:
   1:././motor.h   **** void drive(uint32_t steps, char leftDir, char rightDir) // leftDir[0=reverse,1=forward], rightDir[0
 113               		.loc 1 1 0
 114 0064 0F5F      		subi r16,-1
 115 0066 1F4F      		sbci r17,-1
 116               	.LVL3:
 117               	.LBB61:
 118               		.loc 1 18 0
 119 0068 B801      		movw r22,r16
 120 006a 8827      		clr r24
 121 006c 77FD      		sbrc r23,7
 122 006e 8095      		com r24
 123 0070 982F      		mov r25,r24
 124 0072 00D0      		rcall __floatsisf
 125               	.LVL4:
 126 0074 00D0      		rcall sqrt
 127               	.LVL5:
 128 0076 2B01      		movw r4,r22
 129 0078 3C01      		movw r6,r24
 130 007a BE01      		movw r22,r28
 131 007c 8827      		clr r24
 132 007e 77FD      		sbrc r23,7
 133 0080 8095      		com r24
 134 0082 982F      		mov r25,r24
 135 0084 00D0      		rcall __floatsisf
 136               	.LVL6:
 137 0086 00D0      		rcall sqrt
 138               	.LVL7:
 139 0088 9B01      		movw r18,r22
 140 008a AC01      		movw r20,r24
 141 008c C301      		movw r24,r6
 142 008e B201      		movw r22,r4
 143 0090 00D0      		rcall __subsf3
 144               	.LVL8:
 145 0092 20E0      		ldi r18,0
 146 0094 30E0      		ldi r19,0
 147 0096 4AE7      		ldi r20,lo8(122)
 148 0098 54E4      		ldi r21,lo8(68)
 149 009a 00D0      		rcall __mulsf3
 150               	.LVL9:
 151 009c 262E      		mov r2,r22
 152 009e 372E      		mov r3,r23
 153 00a0 482E      		mov r4,r24
 154 00a2 592E      		mov r5,r25
 155 00a4 962E      		mov r9,r22
 156 00a6 872E      		mov r8,r23
 157 00a8 782E      		mov r7,r24
 158 00aa 692E      		mov r6,r25
 159 00ac E501      		movw r28,r10
 160               	.LVL10:
 161 00ae 00C0      		rjmp .L8
 162               	.LVL11:
 163               	.L9:
 164               	.LBB59:
 165               	.LBB60:
 166               		.file 2 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h"
   1:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
   6:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
   9:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  12:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  17:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  21:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  33:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  35:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  38:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  41:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  42:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  46:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /** \file */
  47:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \code
  49:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \endcode
  53:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  54:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     used.
  58:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  59:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  68:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  77:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  81:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** */
  82:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  83:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  87:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  88:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  93:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  94:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
  97:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
  98:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
 103:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 104:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /**
 105:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 107:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 109:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 112:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 114:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 120:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 125:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 129:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 132:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 140:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****  */
 141:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** void
 142:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** {
 144:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 153:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 156:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 159:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#else
 160:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#endif
 163:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 164:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 165:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 166:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #else
 167:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	{
 172:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		{
 176:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		}
 180:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		return;
 181:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	}
 182:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	else
 183:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #endif
 186:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** }
 187:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 188:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** /**
 189:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 191:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 193:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 196:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 198:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 202:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   
 207:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 211:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****  
 214:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 222:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****  */
 223:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** void
 224:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** {
 226:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 235:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 238:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 241:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#else
 242:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		//round up by default
 243:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	#endif
 245:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 
 246:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 167               		.loc 2 246 0
 168 00b0 95E0      		ldi r25,lo8(5)
 169 00b2 9A95      		1: dec r25
 170 00b4 01F4      		brne 1b
 171 00b6 0000      		nop
 172               	.LBE60:
 173               	.LBE59:
 174               		.loc 1 18 0
 175 00b8 2196      		adiw r28,1
 176               	.LVL12:
 177               	.L8:
 178               		.loc 1 18 0 is_stmt 0 discriminator 1
 179 00ba BE01      		movw r22,r28
 180 00bc 8827      		clr r24
 181 00be 77FD      		sbrc r23,7
 182 00c0 8095      		com r24
 183 00c2 982F      		mov r25,r24
 184 00c4 00D0      		rcall __floatsisf
 185               	.LVL13:
 186 00c6 292D      		mov r18,r9
 187 00c8 382D      		mov r19,r8
 188 00ca 472D      		mov r20,r7
 189 00cc 562D      		mov r21,r6
 190 00ce 00D0      		rcall __ltsf2
 191               	.LVL14:
 192 00d0 8823      		tst r24
 193 00d2 04F0      		brlt .L9
 194               	.LBE61:
  19:././motor.h   **** 				_delay_us(1);
  20:././motor.h   **** 			PORTD &= ~((1<<MOTOR_CLOCK_LEFT) | (1<<MOTOR_CLOCK_RIGHT));
 195               		.loc 1 20 0 is_stmt 1
 196 00d4 82B3      		in r24,0x12
 197 00d6 877E      		andi r24,lo8(-25)
 198 00d8 82BB      		out 0x12,r24
 199               	.LVL15:
 200               	.LBB62:
  21:././motor.h   **** 			for(int j = 0; j < 1000*(sqrt(i+1)-sqrt(i)); j++)
 201               		.loc 1 21 0
 202 00da 20E0      		ldi r18,0
 203 00dc 30E0      		ldi r19,0
 204 00de A901      		movw r20,r18
 205 00e0 622D      		mov r22,r2
 206 00e2 732D      		mov r23,r3
 207 00e4 842D      		mov r24,r4
 208 00e6 952D      		mov r25,r5
 209 00e8 00D0      		rcall __gtsf2
 210               	.LVL16:
 211 00ea 1816      		cp __zero_reg__,r24
 212 00ec 04F4      		brge .L47
 213 00ee E501      		movw r28,r10
 214               	.LVL17:
 215               	.L12:
 216               	.LBB63:
 217               	.LBB64:
 218               		.loc 2 246 0
 219 00f0 85E0      		ldi r24,lo8(5)
 220 00f2 8A95      		1: dec r24
 221 00f4 01F4      		brne 1b
 222 00f6 0000      		nop
 223               	.LBE64:
 224               	.LBE63:
 225               		.loc 1 21 0
 226 00f8 2196      		adiw r28,1
 227               	.LVL18:
 228 00fa BE01      		movw r22,r28
 229 00fc 8827      		clr r24
 230 00fe 77FD      		sbrc r23,7
 231 0100 8095      		com r24
 232 0102 982F      		mov r25,r24
 233 0104 00D0      		rcall __floatsisf
 234               	.LVL19:
 235 0106 9B01      		movw r18,r22
 236 0108 AC01      		movw r20,r24
 237 010a 692D      		mov r22,r9
 238 010c 782D      		mov r23,r8
 239 010e 872D      		mov r24,r7
 240 0110 962D      		mov r25,r6
 241 0112 00D0      		rcall __gtsf2
 242               	.LVL20:
 243 0114 1816      		cp __zero_reg__,r24
 244 0116 04F0      		brlt .L12
 245               	.LVL21:
 246               	.L47:
 247 0118 E801      		movw r28,r16
 248               	.LVL22:
 249               	.LBE62:
  15:././motor.h   **** 		for(int i = 1; i <= (steps / 2); i+=1)
 250               		.loc 1 15 0 discriminator 1
 251 011a C801      		movw r24,r16
 252 011c AA27      		clr r26
 253 011e 97FD      		sbrc r25,7
 254 0120 A095      		com r26
 255 0122 BA2F      		mov r27,r26
 256 0124 C816      		cp r12,r24
 257 0126 D906      		cpc r13,r25
 258 0128 EA06      		cpc r14,r26
 259 012a FB06      		cpc r15,r27
 260 012c 00F0      		brlo .+2
 261 012e 00C0      		rjmp .L13
 262               	.LVL23:
 263               	.LBE57:
 264               	.LBB65:
  22:././motor.h   **** 				_delay_us(1);
  23:././motor.h   **** 		}
  24:././motor.h   **** 		for(int i = (steps / 2); i >= 1; i-=1)
 265               		.loc 1 24 0
 266 0130 1C14      		cp __zero_reg__,r12
 267 0132 1D04      		cpc __zero_reg__,r13
 268 0134 04F0      		brlt .+2
 269 0136 00C0      		rjmp .L1
 270               	.LBB66:
  25:././motor.h   **** 		{
  26:././motor.h   **** 			PORTD |= (1<<MOTOR_CLOCK_LEFT) | (1<<MOTOR_CLOCK_RIGHT);
  27:././motor.h   **** 			for(int j = 0; j < 1000*(sqrt(i+1)-sqrt(i)); j++)
 271               		.loc 1 27 0
 272 0138 00E0      		ldi r16,0
 273 013a 10E0      		ldi r17,0
 274               	.LVL24:
 275               	.L38:
 276               	.LBE66:
  26:././motor.h   **** 			PORTD |= (1<<MOTOR_CLOCK_LEFT) | (1<<MOTOR_CLOCK_RIGHT);
 277               		.loc 1 26 0
 278 013c 82B3      		in r24,0x12
 279 013e 8861      		ori r24,lo8(24)
 280 0140 82BB      		out 0x12,r24
 281               	.LVL25:
 282               	.LBB69:
   1:././motor.h   **** void drive(uint32_t steps, char leftDir, char rightDir) // leftDir[0=reverse,1=forward], rightDir[0
 283               		.loc 1 1 0
 284 0142 B601      		movw r22,r12
 285 0144 6F5F      		subi r22,-1
 286 0146 7F4F      		sbci r23,-1
 287               		.loc 1 27 0
 288 0148 8827      		clr r24
 289 014a 77FD      		sbrc r23,7
 290 014c 8095      		com r24
 291 014e 982F      		mov r25,r24
 292 0150 00D0      		rcall __floatsisf
 293               	.LVL26:
 294 0152 00D0      		rcall sqrt
 295               	.LVL27:
 296 0154 4B01      		movw r8,r22
 297 0156 5C01      		movw r10,r24
 298 0158 B601      		movw r22,r12
 299 015a 8827      		clr r24
 300 015c 77FD      		sbrc r23,7
 301 015e 8095      		com r24
 302 0160 982F      		mov r25,r24
 303 0162 00D0      		rcall __floatsisf
 304               	.LVL28:
 305 0164 00D0      		rcall sqrt
 306               	.LVL29:
 307 0166 9B01      		movw r18,r22
 308 0168 AC01      		movw r20,r24
 309 016a C501      		movw r24,r10
 310 016c B401      		movw r22,r8
 311 016e 00D0      		rcall __subsf3
 312               	.LVL30:
 313 0170 20E0      		ldi r18,0
 314 0172 30E0      		ldi r19,0
 315 0174 4AE7      		ldi r20,lo8(122)
 316 0176 54E4      		ldi r21,lo8(68)
 317 0178 00D0      		rcall __mulsf3
 318               	.LVL31:
 319 017a 662E      		mov r6,r22
 320 017c 772E      		mov r7,r23
 321 017e 882E      		mov r8,r24
 322 0180 992E      		mov r9,r25
 323 0182 F62E      		mov r15,r22
 324 0184 E72E      		mov r14,r23
 325 0186 B82E      		mov r11,r24
 326 0188 A92E      		mov r10,r25
 327 018a E801      		movw r28,r16
 328 018c 00C0      		rjmp .L15
 329               	.LVL32:
 330               	.L16:
 331               	.LBB67:
 332               	.LBB68:
 333               		.loc 2 246 0
 334 018e 95E0      		ldi r25,lo8(5)
 335 0190 9A95      		1: dec r25
 336 0192 01F4      		brne 1b
 337 0194 0000      		nop
 338               	.LBE68:
 339               	.LBE67:
 340               		.loc 1 27 0
 341 0196 2196      		adiw r28,1
 342               	.LVL33:
 343               	.L15:
 344               		.loc 1 27 0 is_stmt 0 discriminator 1
 345 0198 BE01      		movw r22,r28
 346 019a 8827      		clr r24
 347 019c 77FD      		sbrc r23,7
 348 019e 8095      		com r24
 349 01a0 982F      		mov r25,r24
 350 01a2 00D0      		rcall __floatsisf
 351               	.LVL34:
 352 01a4 2F2D      		mov r18,r15
 353 01a6 3E2D      		mov r19,r14
 354 01a8 4B2D      		mov r20,r11
 355 01aa 5A2D      		mov r21,r10
 356 01ac 00D0      		rcall __ltsf2
 357               	.LVL35:
 358 01ae 8823      		tst r24
 359 01b0 04F0      		brlt .L16
 360               	.LBE69:
  28:././motor.h   **** 				_delay_us(1);
  29:././motor.h   **** 			PORTD &= ~((1<<MOTOR_CLOCK_LEFT) | (1<<MOTOR_CLOCK_RIGHT));
 361               		.loc 1 29 0 is_stmt 1
 362 01b2 82B3      		in r24,0x12
 363 01b4 877E      		andi r24,lo8(-25)
 364 01b6 82BB      		out 0x12,r24
 365               	.LVL36:
 366               	.LBB70:
  30:././motor.h   **** 			for(int j = 0; j < 1000*(sqrt(i+1)-sqrt(i)); j++)
 367               		.loc 1 30 0
 368 01b8 20E0      		ldi r18,0
 369 01ba 30E0      		ldi r19,0
 370 01bc A901      		movw r20,r18
 371 01be 662D      		mov r22,r6
 372 01c0 772D      		mov r23,r7
 373 01c2 882D      		mov r24,r8
 374 01c4 992D      		mov r25,r9
 375 01c6 00D0      		rcall __gtsf2
 376               	.LVL37:
 377 01c8 1816      		cp __zero_reg__,r24
 378 01ca 04F4      		brge .L17
 379 01cc E801      		movw r28,r16
 380               	.LVL38:
 381               	.L19:
 382               	.LBB71:
 383               	.LBB72:
 384               		.loc 2 246 0
 385 01ce 85E0      		ldi r24,lo8(5)
 386 01d0 8A95      		1: dec r24
 387 01d2 01F4      		brne 1b
 388 01d4 0000      		nop
 389               	.LBE72:
 390               	.LBE71:
 391               		.loc 1 30 0
 392 01d6 2196      		adiw r28,1
 393               	.LVL39:
 394 01d8 BE01      		movw r22,r28
 395 01da 8827      		clr r24
 396 01dc 77FD      		sbrc r23,7
 397 01de 8095      		com r24
 398 01e0 982F      		mov r25,r24
 399 01e2 00D0      		rcall __floatsisf
 400               	.LVL40:
 401 01e4 9B01      		movw r18,r22
 402 01e6 AC01      		movw r20,r24
 403 01e8 6F2D      		mov r22,r15
 404 01ea 7E2D      		mov r23,r14
 405 01ec 8B2D      		mov r24,r11
 406 01ee 9A2D      		mov r25,r10
 407 01f0 00D0      		rcall __gtsf2
 408               	.LVL41:
 409 01f2 1816      		cp __zero_reg__,r24
 410 01f4 04F0      		brlt .L19
 411               	.LVL42:
 412               	.L17:
 413               	.LBE70:
  24:././motor.h   **** 		for(int i = (steps / 2); i >= 1; i-=1)
 414               		.loc 1 24 0
 415 01f6 91E0      		ldi r25,1
 416 01f8 C91A      		sub r12,r25
 417 01fa D108      		sbc r13,__zero_reg__
 418               	.LVL43:
 419 01fc 01F0      		breq .+2
 420 01fe 00C0      		rjmp .L38
 421 0200 00C0      		rjmp .L1
 422               	.LVL44:
 423               	.L33:
 424               	.LBE65:
  13:././motor.h   **** 	if(steps <= 3000)
 425               		.loc 1 13 0
 426 0202 02E0      		ldi r16,lo8(2)
 427 0204 10E0      		ldi r17,0
 428               	.LBB73:
 429               	.LBB74:
  31:././motor.h   **** 				_delay_us(1);
  32:././motor.h   **** 		}
  33:././motor.h   **** 	}
  34:././motor.h   **** 	else
  35:././motor.h   **** 	{
  36:././motor.h   **** 		for(int i = 1; i <= 1500; i+=1)
  37:././motor.h   **** 		{
  38:././motor.h   **** 			PORTD |= (1<<MOTOR_CLOCK_LEFT) | (1<<MOTOR_CLOCK_RIGHT);
  39:././motor.h   **** 			for(int j = 0; j < 1000*(sqrt(i+1)-sqrt(i)); j++)
 430               		.loc 1 39 0
 431 0206 A12C      		mov r10,__zero_reg__
 432 0208 B12C      		mov r11,__zero_reg__
 433               	.LVL45:
 434               	.L6:
 435               	.LBE74:
  38:././motor.h   **** 			PORTD |= (1<<MOTOR_CLOCK_LEFT) | (1<<MOTOR_CLOCK_RIGHT);
 436               		.loc 1 38 0
 437 020a 82B3      		in r24,0x12
 438 020c 8861      		ori r24,lo8(24)
 439 020e 82BB      		out 0x12,r24
 440               	.LVL46:
 441               	.LBB77:
 442               		.loc 1 39 0
 443 0210 B801      		movw r22,r16
 444 0212 8827      		clr r24
 445 0214 77FD      		sbrc r23,7
 446 0216 8095      		com r24
 447 0218 982F      		mov r25,r24
 448 021a 00D0      		rcall __floatsisf
 449               	.LVL47:
 450 021c 00D0      		rcall sqrt
 451               	.LVL48:
 452 021e 2B01      		movw r4,r22
 453 0220 3C01      		movw r6,r24
   1:././motor.h   **** void drive(uint32_t steps, char leftDir, char rightDir) // leftDir[0=reverse,1=forward], rightDir[0
 454               		.loc 1 1 0
 455 0222 B801      		movw r22,r16
 456 0224 6150      		subi r22,1
 457 0226 7109      		sbc r23,__zero_reg__
 458               		.loc 1 39 0
 459 0228 8827      		clr r24
 460 022a 77FD      		sbrc r23,7
 461 022c 8095      		com r24
 462 022e 982F      		mov r25,r24
 463 0230 00D0      		rcall __floatsisf
 464               	.LVL49:
 465 0232 00D0      		rcall sqrt
 466               	.LVL50:
 467 0234 9B01      		movw r18,r22
 468 0236 AC01      		movw r20,r24
 469 0238 C301      		movw r24,r6
 470 023a B201      		movw r22,r4
 471 023c 00D0      		rcall __subsf3
 472               	.LVL51:
 473 023e 20E0      		ldi r18,0
 474 0240 30E0      		ldi r19,0
 475 0242 4AE7      		ldi r20,lo8(122)
 476 0244 54E4      		ldi r21,lo8(68)
 477 0246 00D0      		rcall __mulsf3
 478               	.LVL52:
 479 0248 262E      		mov r2,r22
 480 024a 372E      		mov r3,r23
 481 024c 482E      		mov r4,r24
 482 024e 592E      		mov r5,r25
 483 0250 962E      		mov r9,r22
 484 0252 872E      		mov r8,r23
 485 0254 782E      		mov r7,r24
 486 0256 692E      		mov r6,r25
 487 0258 E501      		movw r28,r10
 488 025a 00C0      		rjmp .L21
 489               	.LVL53:
 490               	.L22:
 491               	.LBB75:
 492               	.LBB76:
 493               		.loc 2 246 0
 494 025c 85E0      		ldi r24,lo8(5)
 495 025e 8A95      		1: dec r24
 496 0260 01F4      		brne 1b
 497 0262 0000      		nop
 498               	.LBE76:
 499               	.LBE75:
 500               		.loc 1 39 0
 501 0264 2196      		adiw r28,1
 502               	.LVL54:
 503               	.L21:
 504               		.loc 1 39 0 is_stmt 0 discriminator 1
 505 0266 BE01      		movw r22,r28
 506 0268 8827      		clr r24
 507 026a 77FD      		sbrc r23,7
 508 026c 8095      		com r24
 509 026e 982F      		mov r25,r24
 510 0270 00D0      		rcall __floatsisf
 511               	.LVL55:
 512 0272 292D      		mov r18,r9
 513 0274 382D      		mov r19,r8
 514 0276 472D      		mov r20,r7
 515 0278 562D      		mov r21,r6
 516 027a 00D0      		rcall __ltsf2
 517               	.LVL56:
 518 027c 8823      		tst r24
 519 027e 04F0      		brlt .L22
 520               	.LBE77:
  40:././motor.h   **** 				_delay_us(1);
  41:././motor.h   **** 			PORTD &= ~((1<<MOTOR_CLOCK_LEFT) | (1<<MOTOR_CLOCK_RIGHT));
 521               		.loc 1 41 0 is_stmt 1
 522 0280 82B3      		in r24,0x12
 523 0282 877E      		andi r24,lo8(-25)
 524 0284 82BB      		out 0x12,r24
 525               	.LVL57:
 526               	.LBB78:
  42:././motor.h   **** 			for(int j = 0; j < 1000*(sqrt(i+1)-sqrt(i)); j++)
 527               		.loc 1 42 0
 528 0286 20E0      		ldi r18,0
 529 0288 30E0      		ldi r19,0
 530 028a A901      		movw r20,r18
 531 028c 622D      		mov r22,r2
 532 028e 732D      		mov r23,r3
 533 0290 842D      		mov r24,r4
 534 0292 952D      		mov r25,r5
 535 0294 00D0      		rcall __gtsf2
 536               	.LVL58:
 537 0296 1816      		cp __zero_reg__,r24
 538 0298 04F4      		brge .L23
 539 029a E501      		movw r28,r10
 540               	.LVL59:
 541               	.L25:
 542               	.LBB79:
 543               	.LBB80:
 544               		.loc 2 246 0
 545 029c 95E0      		ldi r25,lo8(5)
 546 029e 9A95      		1: dec r25
 547 02a0 01F4      		brne 1b
 548 02a2 0000      		nop
 549               	.LBE80:
 550               	.LBE79:
 551               		.loc 1 42 0
 552 02a4 2196      		adiw r28,1
 553               	.LVL60:
 554 02a6 BE01      		movw r22,r28
 555 02a8 8827      		clr r24
 556 02aa 77FD      		sbrc r23,7
 557 02ac 8095      		com r24
 558 02ae 982F      		mov r25,r24
 559 02b0 00D0      		rcall __floatsisf
 560               	.LVL61:
 561 02b2 9B01      		movw r18,r22
 562 02b4 AC01      		movw r20,r24
 563 02b6 692D      		mov r22,r9
 564 02b8 782D      		mov r23,r8
 565 02ba 872D      		mov r24,r7
 566 02bc 962D      		mov r25,r6
 567 02be 00D0      		rcall __gtsf2
 568               	.LVL62:
 569 02c0 1816      		cp __zero_reg__,r24
 570 02c2 04F0      		brlt .L25
 571               	.LVL63:
 572               	.L23:
 573 02c4 0F5F      		subi r16,-1
 574 02c6 1F4F      		sbci r17,-1
 575               	.LVL64:
 576               	.LBE78:
  36:././motor.h   **** 		for(int i = 1; i <= 1500; i+=1)
 577               		.loc 1 36 0
 578 02c8 0E3D      		cpi r16,-34
 579 02ca 85E0      		ldi r24,5
 580 02cc 1807      		cpc r17,r24
 581 02ce 01F0      		breq .+2
 582 02d0 00C0      		rjmp .L6
 583               	.LVL65:
 584               	.LBE73:
 585               	.LBB81:
  43:././motor.h   **** 				_delay_us(1);
  44:././motor.h   **** 		}
  45:././motor.h   **** 		for(int i = 0; i <= (steps - 3000); i+=1)
 586               		.loc 1 45 0 discriminator 1
 587 02d2 98EB      		ldi r25,-72
 588 02d4 C91A      		sub r12,r25
 589 02d6 9BE0      		ldi r25,11
 590 02d8 D90A      		sbc r13,r25
 591 02da E108      		sbc r14,__zero_reg__
 592 02dc F108      		sbc r15,__zero_reg__
 593               	.LVL66:
 594 02de 20E0      		ldi r18,0
 595 02e0 30E0      		ldi r19,0
 596               	.LVL67:
 597               	.L26:
  46:././motor.h   **** 		{
  47:././motor.h   **** 			PORTD |= (1<<MOTOR_CLOCK_LEFT) | (1<<MOTOR_CLOCK_RIGHT);
 598               		.loc 1 47 0 discriminator 2
 599 02e2 82B3      		in r24,0x12
 600 02e4 8861      		ori r24,lo8(24)
 601 02e6 82BB      		out 0x12,r24
 602               	.LVL68:
 603               	.LBB82:
 604               	.LBB83:
 605               		.loc 2 246 0 discriminator 2
 606 02e8 8FE7      		ldi r24,lo8(639)
 607 02ea 92E0      		ldi r25,hi8(639)
 608 02ec 0197      		1: sbiw r24,1
 609 02ee 01F4      		brne 1b
 610 02f0 00C0      		rjmp .
 611 02f2 0000      		nop
 612               	.LBE83:
 613               	.LBE82:
  48:././motor.h   **** 			_delay_us(160);
  49:././motor.h   **** 			PORTD &= ~((1<<MOTOR_CLOCK_LEFT) | (1<<MOTOR_CLOCK_RIGHT));
 614               		.loc 1 49 0 discriminator 2
 615 02f4 82B3      		in r24,0x12
 616 02f6 877E      		andi r24,lo8(-25)
 617 02f8 82BB      		out 0x12,r24
 618               	.LVL69:
 619               	.LBB84:
 620               	.LBB85:
 621               		.loc 2 246 0 discriminator 2
 622 02fa 8FE7      		ldi r24,lo8(639)
 623 02fc 92E0      		ldi r25,hi8(639)
 624 02fe 0197      		1: sbiw r24,1
 625 0300 01F4      		brne 1b
 626 0302 00C0      		rjmp .
 627 0304 0000      		nop
 628               	.LBE85:
 629               	.LBE84:
  45:././motor.h   **** 		for(int i = 0; i <= (steps - 3000); i+=1)
 630               		.loc 1 45 0 discriminator 2
 631 0306 2F5F      		subi r18,-1
 632 0308 3F4F      		sbci r19,-1
 633               	.LVL70:
 634 030a C901      		movw r24,r18
 635 030c AA27      		clr r26
 636 030e 97FD      		sbrc r25,7
 637 0310 A095      		com r26
 638 0312 BA2F      		mov r27,r26
 639 0314 C816      		cp r12,r24
 640 0316 D906      		cpc r13,r25
 641 0318 EA06      		cpc r14,r26
 642 031a FB06      		cpc r15,r27
 643 031c 00F4      		brsh .L26
  45:././motor.h   **** 		for(int i = 0; i <= (steps - 3000); i+=1)
 644               		.loc 1 45 0 is_stmt 0
 645 031e 0CED      		ldi r16,lo8(-36)
 646 0320 15E0      		ldi r17,lo8(5)
 647               	.LVL71:
 648               	.LBE81:
 649               	.LBB86:
 650               	.LBB87:
  50:././motor.h   **** 			_delay_us(160);
  51:././motor.h   **** 		}
  52:././motor.h   **** 		for(int i = 1500; i >= 1; i-=1)
  53:././motor.h   **** 		{
  54:././motor.h   **** 			PORTD |= (1<<MOTOR_CLOCK_LEFT) | (1<<MOTOR_CLOCK_RIGHT);
  55:././motor.h   **** 			for(int j = 0; j < 1000*(sqrt(i+1)-sqrt(i)); j++)
 651               		.loc 1 55 0 is_stmt 1
 652 0322 E12C      		mov r14,__zero_reg__
 653 0324 F12C      		mov r15,__zero_reg__
 654               	.LVL72:
 655               	.L32:
 656               	.LBE87:
  54:././motor.h   **** 			PORTD |= (1<<MOTOR_CLOCK_LEFT) | (1<<MOTOR_CLOCK_RIGHT);
 657               		.loc 1 54 0
 658 0326 82B3      		in r24,0x12
 659 0328 8861      		ori r24,lo8(24)
 660 032a 82BB      		out 0x12,r24
 661               	.LVL73:
 662               	.LBB90:
   1:././motor.h   **** void drive(uint32_t steps, char leftDir, char rightDir) // leftDir[0=reverse,1=forward], rightDir[0
 663               		.loc 1 1 0
 664 032c B801      		movw r22,r16
 665 032e 6F5F      		subi r22,-1
 666 0330 7F4F      		sbci r23,-1
 667               		.loc 1 55 0
 668 0332 8827      		clr r24
 669 0334 77FD      		sbrc r23,7
 670 0336 8095      		com r24
 671 0338 982F      		mov r25,r24
 672 033a 00D0      		rcall __floatsisf
 673               	.LVL74:
 674 033c 00D0      		rcall sqrt
 675               	.LVL75:
 676 033e 4B01      		movw r8,r22
 677 0340 5C01      		movw r10,r24
 678 0342 B801      		movw r22,r16
 679 0344 8827      		clr r24
 680 0346 77FD      		sbrc r23,7
 681 0348 8095      		com r24
 682 034a 982F      		mov r25,r24
 683 034c 00D0      		rcall __floatsisf
 684               	.LVL76:
 685 034e 00D0      		rcall sqrt
 686               	.LVL77:
 687 0350 9B01      		movw r18,r22
 688 0352 AC01      		movw r20,r24
 689 0354 C501      		movw r24,r10
 690 0356 B401      		movw r22,r8
 691 0358 00D0      		rcall __subsf3
 692               	.LVL78:
 693 035a 20E0      		ldi r18,0
 694 035c 30E0      		ldi r19,0
 695 035e 4AE7      		ldi r20,lo8(122)
 696 0360 54E4      		ldi r21,lo8(68)
 697 0362 00D0      		rcall __mulsf3
 698               	.LVL79:
 699 0364 662E      		mov r6,r22
 700 0366 772E      		mov r7,r23
 701 0368 882E      		mov r8,r24
 702 036a 992E      		mov r9,r25
 703 036c D62E      		mov r13,r22
 704 036e C72E      		mov r12,r23
 705 0370 B82E      		mov r11,r24
 706 0372 A92E      		mov r10,r25
 707 0374 E701      		movw r28,r14
 708 0376 00C0      		rjmp .L27
 709               	.LVL80:
 710               	.L28:
 711               	.LBB88:
 712               	.LBB89:
 713               		.loc 2 246 0
 714 0378 95E0      		ldi r25,lo8(5)
 715 037a 9A95      		1: dec r25
 716 037c 01F4      		brne 1b
 717 037e 0000      		nop
 718               	.LBE89:
 719               	.LBE88:
 720               		.loc 1 55 0
 721 0380 2196      		adiw r28,1
 722               	.LVL81:
 723               	.L27:
 724               		.loc 1 55 0 is_stmt 0 discriminator 1
 725 0382 BE01      		movw r22,r28
 726 0384 8827      		clr r24
 727 0386 77FD      		sbrc r23,7
 728 0388 8095      		com r24
 729 038a 982F      		mov r25,r24
 730 038c 00D0      		rcall __floatsisf
 731               	.LVL82:
 732 038e 2D2D      		mov r18,r13
 733 0390 3C2D      		mov r19,r12
 734 0392 4B2D      		mov r20,r11
 735 0394 5A2D      		mov r21,r10
 736 0396 00D0      		rcall __ltsf2
 737               	.LVL83:
 738 0398 8823      		tst r24
 739 039a 04F0      		brlt .L28
 740               	.LBE90:
  56:././motor.h   **** 				_delay_us(1);
  57:././motor.h   **** 			PORTD &= ~((1<<MOTOR_CLOCK_LEFT) | (1<<MOTOR_CLOCK_RIGHT));
 741               		.loc 1 57 0 is_stmt 1
 742 039c 82B3      		in r24,0x12
 743 039e 877E      		andi r24,lo8(-25)
 744 03a0 82BB      		out 0x12,r24
 745               	.LVL84:
 746               	.LBB91:
  58:././motor.h   **** 			for(int j = 0; j < 1000*(sqrt(i+1)-sqrt(i)); j++)
 747               		.loc 1 58 0
 748 03a2 20E0      		ldi r18,0
 749 03a4 30E0      		ldi r19,0
 750 03a6 A901      		movw r20,r18
 751 03a8 662D      		mov r22,r6
 752 03aa 772D      		mov r23,r7
 753 03ac 882D      		mov r24,r8
 754 03ae 992D      		mov r25,r9
 755 03b0 00D0      		rcall __gtsf2
 756               	.LVL85:
 757 03b2 1816      		cp __zero_reg__,r24
 758 03b4 04F4      		brge .L29
 759 03b6 E701      		movw r28,r14
 760               	.LVL86:
 761               	.L31:
 762               	.LBB92:
 763               	.LBB93:
 764               		.loc 2 246 0
 765 03b8 85E0      		ldi r24,lo8(5)
 766 03ba 8A95      		1: dec r24
 767 03bc 01F4      		brne 1b
 768 03be 0000      		nop
 769               	.LBE93:
 770               	.LBE92:
 771               		.loc 1 58 0
 772 03c0 2196      		adiw r28,1
 773               	.LVL87:
 774 03c2 BE01      		movw r22,r28
 775 03c4 8827      		clr r24
 776 03c6 77FD      		sbrc r23,7
 777 03c8 8095      		com r24
 778 03ca 982F      		mov r25,r24
 779 03cc 00D0      		rcall __floatsisf
 780               	.LVL88:
 781 03ce 9B01      		movw r18,r22
 782 03d0 AC01      		movw r20,r24
 783 03d2 6D2D      		mov r22,r13
 784 03d4 7C2D      		mov r23,r12
 785 03d6 8B2D      		mov r24,r11
 786 03d8 9A2D      		mov r25,r10
 787 03da 00D0      		rcall __gtsf2
 788               	.LVL89:
 789 03dc 1816      		cp __zero_reg__,r24
 790 03de 04F0      		brlt .L31
 791               	.LVL90:
 792               	.L29:
 793               	.LBE91:
  52:././motor.h   **** 		for(int i = 1500; i >= 1; i-=1)
 794               		.loc 1 52 0
 795 03e0 0150      		subi r16,1
 796 03e2 1109      		sbc r17,__zero_reg__
 797               	.LVL91:
 798 03e4 01F0      		breq .+2
 799 03e6 00C0      		rjmp .L32
 800               	.LVL92:
 801               	.L1:
 802               	/* epilogue start */
 803               	.LBE86:
  59:././motor.h   **** 				_delay_us(1);
  60:././motor.h   **** 		}
  61:././motor.h   **** 	}
  62:././motor.h   **** }
 804               		.loc 1 62 0
 805 03e8 DF91      		pop r29
 806 03ea CF91      		pop r28
 807 03ec 1F91      		pop r17
 808 03ee 0F91      		pop r16
 809 03f0 FF90      		pop r15
 810 03f2 EF90      		pop r14
 811 03f4 DF90      		pop r13
 812 03f6 CF90      		pop r12
 813 03f8 BF90      		pop r11
 814 03fa AF90      		pop r10
 815 03fc 9F90      		pop r9
 816 03fe 8F90      		pop r8
 817 0400 7F90      		pop r7
 818 0402 6F90      		pop r6
 819 0404 5F90      		pop r5
 820 0406 4F90      		pop r4
 821 0408 3F90      		pop r3
 822 040a 2F90      		pop r2
 823 040c 0895      		ret
 824               	.LFE7:
 826               	.global	usart_putChar
 828               	usart_putChar:
 829               	.LFB8:
 830               		.file 3 "././usart.h"
   1:././usart.h   **** int usart_putChar(char c,FILE *stream)
   2:././usart.h   **** {
 831               		.loc 3 2 0
 832               	.LVL93:
 833               	/* prologue: function */
 834               	/* frame size = 0 */
 835               	/* stack size = 0 */
 836               	.L__stack_usage = 0
   3:././usart.h   **** 	/* NEW LINE CHARACTER */
   4:././usart.h   **** 	if(c == '\n')
 837               		.loc 3 4 0
 838 040e 8A30      		cpi r24,lo8(10)
 839 0410 01F4      		brne .L52
 840               	.L53:
   5:././usart.h   **** 	{
   6:././usart.h   **** 		while(!(UCSRA & (1 << UDRE)));
 841               		.loc 3 6 0 discriminator 1
 842 0412 5D9B      		sbis 0xb,5
 843 0414 00C0      		rjmp .L53
   7:././usart.h   **** 		UDR = '\r';
 844               		.loc 3 7 0
 845 0416 9DE0      		ldi r25,lo8(13)
 846 0418 9CB9      		out 0xc,r25
 847               	.L52:
   8:././usart.h   **** 	}
   9:././usart.h   **** 	/* CHARACTER */
  10:././usart.h   **** 	while(!(UCSRA & (1 << UDRE)));
 848               		.loc 3 10 0 discriminator 1
 849 041a 5D9B      		sbis 0xb,5
 850 041c 00C0      		rjmp .L52
  11:././usart.h   **** 	UDR = c;
 851               		.loc 3 11 0
 852 041e 8CB9      		out 0xc,r24
  12:././usart.h   **** 	return 0;
  13:././usart.h   **** }
 853               		.loc 3 13 0
 854 0420 80E0      		ldi r24,0
 855 0422 90E0      		ldi r25,0
 856               	.LVL94:
 857 0424 0895      		ret
 858               	.LFE8:
 860               	.global	usart_getChar
 862               	usart_getChar:
 863               	.LFB9:
  14:././usart.h   **** 
  15:././usart.h   **** int usart_getChar(FILE *stream)
  16:././usart.h   **** {
 864               		.loc 3 16 0
 865               	/* prologue: function */
 866               	/* frame size = 0 */
 867               	/* stack size = 0 */
 868               	.L__stack_usage = 0
 869               	.LVL95:
 870               	.L57:
  17:././usart.h   **** 	while(!(UCSRA & (1 << RXC)));
 871               		.loc 3 17 0 discriminator 1
 872 0426 5F9B      		sbis 0xb,7
 873 0428 00C0      		rjmp .L57
  18:././usart.h   **** 	return (int)UDR;
 874               		.loc 3 18 0
 875 042a 8CB1      		in r24,0xc
 876               	.LVL96:
  19:././usart.h   **** }
 877               		.loc 3 19 0
 878 042c 90E0      		ldi r25,0
 879 042e 0895      		ret
 880               	.LFE9:
 882               	.global	usart_init
 884               	usart_init:
 885               	.LFB10:
  20:././usart.h   **** 
  21:././usart.h   **** #define BAUDRATE 2400UL
  22:././usart.h   **** 
  23:././usart.h   **** void usart_init(void)
  24:././usart.h   **** {
 886               		.loc 3 24 0
 887               	/* prologue: function */
 888               	/* frame size = 0 */
 889               	/* stack size = 0 */
 890               	.L__stack_usage = 0
 891               	.LVL97:
  25:././usart.h   **** 	uint16_t ubrr = (uint16_t)((uint32_t)F_CPU / (16 * BAUDRATE) - 1);
  26:././usart.h   ****     UBRRH = (uint8_t)(ubrr>>8);
 892               		.loc 3 26 0
 893 0430 81E0      		ldi r24,lo8(1)
 894 0432 80BD      		out 0x20,r24
  27:././usart.h   ****     UBRRL = (uint8_t)(ubrr);
 895               		.loc 3 27 0
 896 0434 8FE9      		ldi r24,lo8(-97)
 897 0436 89B9      		out 0x9,r24
  28:././usart.h   ****     
  29:././usart.h   **** 	// enable receiver and trasmitter
  30:././usart.h   **** 	UCSRB = (1<<RXEN) | (1<<TXEN);
 898               		.loc 3 30 0
 899 0438 88E1      		ldi r24,lo8(24)
 900 043a 8AB9      		out 0xa,r24
  31:././usart.h   **** 	// set frame format: 1stop bit, 8data
  32:././usart.h   **** 	UCSRC = (1<<URSEL) | (1<<UCSZ1) | (1<<UCSZ0);
 901               		.loc 3 32 0
 902 043c 86E8      		ldi r24,lo8(-122)
 903 043e 80BD      		out 0x20,r24
  33:././usart.h   **** 	
  34:././usart.h   **** 	while(UCSRA & (1 << RXC))
 904               		.loc 3 34 0
 905 0440 5F9B      		sbis 0xb,7
 906 0442 00C0      		rjmp .L59
 907               	.L62:
  35:././usart.h   **** 	{
  36:././usart.h   **** 		UDR;
 908               		.loc 3 36 0
 909 0444 8CB1      		in r24,0xc
  34:././usart.h   **** 	while(UCSRA & (1 << RXC))
 910               		.loc 3 34 0
 911 0446 5F99      		sbic 0xb,7
 912 0448 00C0      		rjmp .L62
 913               	.L59:
 914 044a 0895      		ret
 915               	.LFE10:
 917               	.global	dataBusRead
 919               	dataBusRead:
 920               	.LFB11:
 921               		.file 4 "././communication.h"
   1:././communication.h **** /*void blink(void)
   2:././communication.h **** {
   3:././communication.h **** 	PORTC |= (1<<5);
   4:././communication.h **** 	_delay_ms(1000);
   5:././communication.h **** 	PORTC &= ~(1<<5);
   6:././communication.h **** }*/
   7:././communication.h **** 
   8:././communication.h **** /*void usart_handleCommand(int commandId, char *commandParam)
   9:././communication.h **** {
  10:././communication.h **** 	//blink();
  11:././communication.h **** 	
  12:././communication.h **** 	int tempInputSize = 0;
  13:././communication.h **** 	char *tempInput;
  14:././communication.h **** 	char tempCharacter = 0;
  15:././communication.h **** 	
  16:././communication.h **** 	while(1)
  17:././communication.h **** 	{
  18:././communication.h **** 		while(!(UCSRA & (1 << RXC)));
  19:././communication.h **** 		tempCharacter = UDR;
  20:././communication.h **** 		if(tempInputSize == 0)
  21:././communication.h **** 		{
  22:././communication.h **** 			tempInput = malloc(0);
  23:././communication.h **** 		}
  24:././communication.h **** 		if(tempCharacter != ":")
  25:././communication.h **** 		tempInputSize += 1;
  26:././communication.h **** 		tempInput = realloc(tempInput,tempInputSize * sizeof(char));
  27:././communication.h **** 		tempInput[tempInputSize - 1] = tempCharacter;
  28:././communication.h **** 	}
  29:././communication.h **** 	
  30:././communication.h **** 	switch(commandId)
  31:././communication.h **** 	{
  32:././communication.h **** 		case 0:
  33:././communication.h **** 			printf("%i:%i:%i",100,150,200);
  34:././communication.h **** 			break;
  35:././communication.h **** 	}
  36:././communication.h **** }*/
  37:././communication.h **** 
  38:././communication.h **** char dataBusRead(void)
  39:././communication.h **** {
 922               		.loc 4 39 0
 923               	/* prologue: function */
 924               	/* frame size = 0 */
 925               	/* stack size = 0 */
 926               	.L__stack_usage = 0
 927               	.LVL98:
  40:././communication.h **** 	char byte = 0;
  41:././communication.h **** 	for(int i = 0; i < 8; i++)
 928               		.loc 4 41 0
 929 044c 20E0      		ldi r18,0
 930 044e 30E0      		ldi r19,0
  40:././communication.h **** 	char byte = 0;
 931               		.loc 4 40 0
 932 0450 80E0      		ldi r24,0
 933               	.LBB94:
  42:././communication.h **** 	{
  43:././communication.h **** 		/* WAIT FOR CLOCK */
  44:././communication.h **** 		while(bit_is_clear(PINB,4));
  45:././communication.h **** 		if(bit_is_set(PINB,0))
  46:././communication.h **** 		{
  47:././communication.h **** 			byte |= (1<<i);
  48:././communication.h **** 		}
  49:././communication.h **** 		else
  50:././communication.h **** 		{
  51:././communication.h **** 			byte &= ~(1<<i);
 934               		.loc 4 51 0
 935 0452 41E0      		ldi r20,lo8(1)
 936 0454 50E0      		ldi r21,0
 937               	.LVL99:
 938               	.L74:
  44:././communication.h **** 		while(bit_is_clear(PINB,4));
 939               		.loc 4 44 0 discriminator 1
 940 0456 B49B      		sbis 0x16,4
 941 0458 00C0      		rjmp .L74
  45:././communication.h **** 		if(bit_is_set(PINB,0))
 942               		.loc 4 45 0
 943 045a B09B      		sbis 0x16,0
 944 045c 00C0      		rjmp .L66
  47:././communication.h **** 			byte |= (1<<i);
 945               		.loc 4 47 0
 946 045e BA01      		movw r22,r20
 947 0460 022E      		mov r0,r18
 948 0462 00C0      		rjmp 2f
 949               		1:
 950 0464 660F      		lsl r22
 951 0466 771F      		rol r23
 952               		2:
 953 0468 0A94      		dec r0
 954 046a 02F4      		brpl 1b
 955 046c 862B      		or r24,r22
 956               	.LVL100:
 957 046e 00C0      		rjmp .L71
 958               	.LVL101:
 959               	.L66:
 960               		.loc 4 51 0
 961 0470 BA01      		movw r22,r20
 962 0472 022E      		mov r0,r18
 963 0474 00C0      		rjmp 2f
 964               		1:
 965 0476 660F      		lsl r22
 966 0478 771F      		rol r23
 967               		2:
 968 047a 0A94      		dec r0
 969 047c 02F4      		brpl 1b
 970 047e 6095      		com r22
 971 0480 8623      		and r24,r22
 972               	.LVL102:
 973               	.L71:
  52:././communication.h **** 		}
  53:././communication.h **** 		/* WAIT FOR CLOCK */
  54:././communication.h **** 		while(bit_is_set(PINB,4));
 974               		.loc 4 54 0 discriminator 1
 975 0482 B499      		sbic 0x16,4
 976 0484 00C0      		rjmp .L71
  41:././communication.h **** 	for(int i = 0; i < 8; i++)
 977               		.loc 4 41 0
 978 0486 2F5F      		subi r18,-1
 979 0488 3F4F      		sbci r19,-1
 980               	.LVL103:
 981 048a 2830      		cpi r18,8
 982 048c 3105      		cpc r19,__zero_reg__
 983 048e 01F4      		brne .L74
 984               	/* epilogue start */
 985               	.LBE94:
  55:././communication.h **** 	}
  56:././communication.h **** 	return byte;
  57:././communication.h **** }
 986               		.loc 4 57 0
 987 0490 0895      		ret
 988               	.LFE11:
 990               	.global	dataBusSend
 992               	dataBusSend:
 993               	.LFB12:
  58:././communication.h **** 
  59:././communication.h **** void dataBusSend(char byte)
  60:././communication.h **** {
 994               		.loc 4 60 0
 995               	.LVL104:
 996               	/* prologue: function */
 997               	/* frame size = 0 */
 998               	/* stack size = 0 */
 999               	.L__stack_usage = 0
 1000               	.LBB95:
 1001               	.LBB96:
 164:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1002               		.loc 2 164 0
 1003 0492 EFE1      		ldi r30,lo8(19999)
 1004 0494 FEE4      		ldi r31,hi8(19999)
 1005 0496 3197      		1: sbiw r30,1
 1006 0498 01F4      		brne 1b
 1007 049a 00C0      		rjmp .
 1008 049c 0000      		nop
 1009               	.LVL105:
  61:././communication.h **** 	_delay_ms(5);
  62:././communication.h **** 	for(int i = 0; i < 8; i++)
 1010               		.loc 4 62 0
 1011 049e 20E0      		ldi r18,0
 1012 04a0 30E0      		ldi r19,0
 1013               	.LBE96:
 1014               	.LBE95:
 1015               	.LBB97:
  63:././communication.h **** 	{
  64:././communication.h **** 		if(byte & (1<<i))
 1016               		.loc 4 64 0
 1017 04a2 90E0      		ldi r25,0
 1018               	.LVL106:
 1019               	.L78:
 1020 04a4 AC01      		movw r20,r24
 1021 04a6 022E      		mov r0,r18
 1022 04a8 00C0      		rjmp 2f
 1023               		1:
 1024 04aa 5595      		asr r21
 1025 04ac 4795      		ror r20
 1026               		2:
 1027 04ae 0A94      		dec r0
 1028 04b0 02F4      		brpl 1b
 1029 04b2 40FF      		sbrs r20,0
 1030 04b4 00C0      		rjmp .L76
  65:././communication.h **** 		{
  66:././communication.h **** 			PORTB |= (1<<2);
 1031               		.loc 4 66 0
 1032 04b6 C29A      		sbi 0x18,2
 1033 04b8 00C0      		rjmp .L77
 1034               	.L76:
  67:././communication.h **** 		}
  68:././communication.h **** 		else
  69:././communication.h **** 		{
  70:././communication.h **** 			PORTB &= ~(1<<2);
 1035               		.loc 4 70 0
 1036 04ba C298      		cbi 0x18,2
 1037               	.L77:
  71:././communication.h **** 		}
  72:././communication.h **** 		/* CLOCK */
  73:././communication.h **** 		PORTB |= (1<<3);
 1038               		.loc 4 73 0
 1039 04bc C39A      		sbi 0x18,3
 1040               	.LVL107:
 1041               	.LBB98:
 1042               	.LBB99:
 1043               		.loc 2 246 0
 1044 04be EFEC      		ldi r30,lo8(1999)
 1045 04c0 F7E0      		ldi r31,hi8(1999)
 1046 04c2 3197      		1: sbiw r30,1
 1047 04c4 01F4      		brne 1b
 1048 04c6 00C0      		rjmp .
 1049 04c8 0000      		nop
 1050               	.LBE99:
 1051               	.LBE98:
  74:././communication.h **** 		_delay_us(500);
  75:././communication.h **** 		PORTB &= ~(1<<3);
 1052               		.loc 4 75 0
 1053 04ca C398      		cbi 0x18,3
 1054               	.LVL108:
 1055               	.LBB100:
 1056               	.LBB101:
 1057               		.loc 2 246 0
 1058 04cc EFEC      		ldi r30,lo8(1999)
 1059 04ce F7E0      		ldi r31,hi8(1999)
 1060 04d0 3197      		1: sbiw r30,1
 1061 04d2 01F4      		brne 1b
 1062 04d4 00C0      		rjmp .
 1063 04d6 0000      		nop
 1064               	.LBE101:
 1065               	.LBE100:
  62:././communication.h **** 	for(int i = 0; i < 8; i++)
 1066               		.loc 4 62 0
 1067 04d8 2F5F      		subi r18,-1
 1068 04da 3F4F      		sbci r19,-1
 1069               	.LVL109:
 1070 04dc 2830      		cpi r18,8
 1071 04de 3105      		cpc r19,__zero_reg__
 1072 04e0 01F4      		brne .L78
 1073               	/* epilogue start */
 1074               	.LBE97:
  76:././communication.h **** 		_delay_us(500);
  77:././communication.h **** 	}
  78:././communication.h **** }
 1075               		.loc 4 78 0
 1076 04e2 0895      		ret
 1077               	.LFE12:
 1079               	.global	__floatunsisf
 1080               	.global	__divsf3
 1081               	.global	beep
 1083               	beep:
 1084               	.LFB13:
 1085               		.file 5 "./other.h"
   1:./other.h     **** void beep(uint32_t frequency,uint32_t duration)
   2:./other.h     **** {
 1086               		.loc 5 2 0
 1087               	.LVL110:
 1088 04e4 4F92      		push r4
 1089               	.LCFI18:
 1090 04e6 5F92      		push r5
 1091               	.LCFI19:
 1092 04e8 6F92      		push r6
 1093               	.LCFI20:
 1094 04ea 7F92      		push r7
 1095               	.LCFI21:
 1096 04ec 8F92      		push r8
 1097               	.LCFI22:
 1098 04ee 9F92      		push r9
 1099               	.LCFI23:
 1100 04f0 AF92      		push r10
 1101               	.LCFI24:
 1102 04f2 BF92      		push r11
 1103               	.LCFI25:
 1104 04f4 CF92      		push r12
 1105               	.LCFI26:
 1106 04f6 DF92      		push r13
 1107               	.LCFI27:
 1108 04f8 EF92      		push r14
 1109               	.LCFI28:
 1110 04fa FF92      		push r15
 1111               	.LCFI29:
 1112 04fc 0F93      		push r16
 1113               	.LCFI30:
 1114 04fe 1F93      		push r17
 1115               	.LCFI31:
 1116 0500 CF93      		push r28
 1117               	.LCFI32:
 1118 0502 DF93      		push r29
 1119               	.LCFI33:
 1120               	/* prologue: function */
 1121               	/* frame size = 0 */
 1122               	/* stack size = 16 */
 1123               	.L__stack_usage = 16
 1124 0504 6B01      		movw r12,r22
 1125 0506 7C01      		movw r14,r24
 1126 0508 4901      		movw r8,r18
 1127 050a 5A01      		movw r10,r20
 1128               	.LVL111:
 1129               	.LBB102:
   3:./other.h     **** 	for(int i = 0; i < frequency * ((float)duration / 1000.0); i++)
 1130               		.loc 5 3 0
 1131 050c 00D0      		rcall __floatunsisf
 1132               	.LVL112:
 1133 050e 2B01      		movw r4,r22
 1134 0510 3C01      		movw r6,r24
 1135 0512 C501      		movw r24,r10
 1136 0514 B401      		movw r22,r8
 1137 0516 00D0      		rcall __floatunsisf
 1138               	.LVL113:
 1139 0518 20E0      		ldi r18,0
 1140 051a 30E0      		ldi r19,0
 1141 051c 4AE7      		ldi r20,lo8(122)
 1142 051e 54E4      		ldi r21,lo8(68)
 1143 0520 00D0      		rcall __divsf3
 1144               	.LVL114:
 1145 0522 9B01      		movw r18,r22
 1146 0524 AC01      		movw r20,r24
 1147 0526 C301      		movw r24,r6
 1148 0528 B201      		movw r22,r4
 1149 052a 00D0      		rcall __mulsf3
 1150               	.LVL115:
 1151 052c B62E      		mov r11,r22
 1152 052e A72E      		mov r10,r23
 1153 0530 982E      		mov r9,r24
 1154 0532 892E      		mov r8,r25
 1155               	.LVL116:
 1156 0534 20E0      		ldi r18,0
 1157 0536 30E0      		ldi r19,0
 1158 0538 A901      		movw r20,r18
 1159 053a 00D0      		rcall __gtsf2
 1160               	.LVL117:
 1161 053c 1816      		cp __zero_reg__,r24
 1162 053e 04F0      		brlt .+2
 1163 0540 00C0      		rjmp .L80
 1164               	.LBB103:
   4:./other.h     **** 	{
   5:./other.h     **** 		PORTD |= (1<<5);
   6:./other.h     **** 		for(int j = 0; j < 220000 / frequency; j++)
 1165               		.loc 5 6 0
 1166 0542 60E6      		ldi r22,lo8(96)
 1167 0544 7BE5      		ldi r23,lo8(91)
 1168 0546 83E0      		ldi r24,lo8(3)
 1169 0548 90E0      		ldi r25,0
 1170 054a A701      		movw r20,r14
 1171 054c 9601      		movw r18,r12
 1172 054e 00D0      		rcall __udivmodsi4
 1173 0550 6901      		movw r12,r18
 1174 0552 7A01      		movw r14,r20
 1175               	.LVL118:
   3:./other.h     **** 	for(int i = 0; i < frequency * ((float)duration / 1000.0); i++)
 1176               		.loc 5 3 0
 1177 0554 C0E0      		ldi r28,0
 1178 0556 D0E0      		ldi r29,0
 1179               		.loc 5 6 0
 1180 0558 00E0      		ldi r16,0
 1181 055a 10E0      		ldi r17,0
 1182               	.LVL119:
 1183               	.L86:
 1184               	.LBE103:
   5:./other.h     **** 		PORTD |= (1<<5);
 1185               		.loc 5 5 0
 1186 055c 959A      		sbi 0x12,5
 1187               	.LVL120:
 1188               	.LBB106:
 1189               		.loc 5 6 0
 1190 055e C114      		cp r12,__zero_reg__
 1191 0560 D104      		cpc r13,__zero_reg__
 1192 0562 E104      		cpc r14,__zero_reg__
 1193 0564 F104      		cpc r15,__zero_reg__
 1194 0566 01F0      		breq .L83
 1195 0568 9801      		movw r18,r16
 1196               	.LVL121:
 1197               	.L84:
 1198               	.LBB104:
 1199               	.LBB105:
 1200               		.loc 2 246 0
 1201 056a 85E0      		ldi r24,lo8(5)
 1202 056c 8A95      		1: dec r24
 1203 056e 01F4      		brne 1b
 1204 0570 0000      		nop
 1205               	.LBE105:
 1206               	.LBE104:
 1207               		.loc 5 6 0
 1208 0572 2F5F      		subi r18,-1
 1209 0574 3F4F      		sbci r19,-1
 1210               	.LVL122:
 1211 0576 C901      		movw r24,r18
 1212 0578 AA27      		clr r26
 1213 057a 97FD      		sbrc r25,7
 1214 057c A095      		com r26
 1215 057e BA2F      		mov r27,r26
 1216 0580 8C15      		cp r24,r12
 1217 0582 9D05      		cpc r25,r13
 1218 0584 AE05      		cpc r26,r14
 1219 0586 BF05      		cpc r27,r15
 1220 0588 00F0      		brlo .L84
 1221               	.LBE106:
   7:./other.h     **** 			_delay_us(1);
   8:./other.h     **** 		PORTD &= ~(1<<5);
 1222               		.loc 5 8 0
 1223 058a 9598      		cbi 0x12,5
 1224               	.LVL123:
   9:./other.h     **** 		for(int j = 0; j < 220000 / frequency; j++)
 1225               		.loc 5 9 0
 1226 058c 9801      		movw r18,r16
 1227               	.LVL124:
 1228               	.L85:
 1229               	.LBB107:
 1230               	.LBB108:
 1231               	.LBB109:
 1232               		.loc 2 246 0
 1233 058e 85E0      		ldi r24,lo8(5)
 1234 0590 8A95      		1: dec r24
 1235 0592 01F4      		brne 1b
 1236 0594 0000      		nop
 1237               	.LBE109:
 1238               	.LBE108:
 1239               		.loc 5 9 0
 1240 0596 2F5F      		subi r18,-1
 1241 0598 3F4F      		sbci r19,-1
 1242               	.LVL125:
 1243 059a C901      		movw r24,r18
 1244 059c AA27      		clr r26
 1245 059e 97FD      		sbrc r25,7
 1246 05a0 A095      		com r26
 1247 05a2 BA2F      		mov r27,r26
 1248 05a4 8C15      		cp r24,r12
 1249 05a6 9D05      		cpc r25,r13
 1250 05a8 AE05      		cpc r26,r14
 1251 05aa BF05      		cpc r27,r15
 1252 05ac 00F0      		brlo .L85
 1253               	.LVL126:
 1254               	.L87:
 1255               	.LBE107:
   3:./other.h     **** 	for(int i = 0; i < frequency * ((float)duration / 1000.0); i++)
 1256               		.loc 5 3 0
 1257 05ae 2196      		adiw r28,1
 1258               	.LVL127:
 1259 05b0 BE01      		movw r22,r28
 1260 05b2 8827      		clr r24
 1261 05b4 77FD      		sbrc r23,7
 1262 05b6 8095      		com r24
 1263 05b8 982F      		mov r25,r24
 1264 05ba 00D0      		rcall __floatsisf
 1265               	.LVL128:
 1266 05bc 2B2D      		mov r18,r11
 1267 05be 3A2D      		mov r19,r10
 1268 05c0 492D      		mov r20,r9
 1269 05c2 582D      		mov r21,r8
 1270 05c4 00D0      		rcall __ltsf2
 1271               	.LVL129:
 1272 05c6 8823      		tst r24
 1273 05c8 04F0      		brlt .L86
 1274 05ca 00C0      		rjmp .L80
 1275               	.LVL130:
 1276               	.L83:
   8:./other.h     **** 		PORTD &= ~(1<<5);
 1277               		.loc 5 8 0
 1278 05cc 9598      		cbi 0x12,5
 1279               	.LVL131:
 1280 05ce 00C0      		rjmp .L87
 1281               	.LVL132:
 1282               	.L80:
 1283               	/* epilogue start */
 1284               	.LBE102:
  10:./other.h     **** 			_delay_us(1);
  11:./other.h     **** 	}
  12:./other.h     **** }
 1285               		.loc 5 12 0
 1286 05d0 DF91      		pop r29
 1287 05d2 CF91      		pop r28
 1288 05d4 1F91      		pop r17
 1289 05d6 0F91      		pop r16
 1290 05d8 FF90      		pop r15
 1291 05da EF90      		pop r14
 1292 05dc DF90      		pop r13
 1293 05de CF90      		pop r12
 1294 05e0 BF90      		pop r11
 1295 05e2 AF90      		pop r10
 1296 05e4 9F90      		pop r9
 1297 05e6 8F90      		pop r8
 1298 05e8 7F90      		pop r7
 1299 05ea 6F90      		pop r6
 1300 05ec 5F90      		pop r5
 1301 05ee 4F90      		pop r4
 1302 05f0 0895      		ret
 1303               	.LFE13:
 1305               	.global	__fixsfsi
 1306               	.global	main
 1308               	main:
 1309               	.LFB14:
 1310               		.file 6 "main.c"
   1:main.c        **** #define MOTOR_ENABLE 0
   2:main.c        **** #define MOTOR_DIR_LEFT 1
   3:main.c        **** #define MOTOR_DIR_RIGHT 2
   4:main.c        **** #define MOTOR_CLOCK_LEFT 3
   5:main.c        **** #define MOTOR_CLOCK_RIGHT 4
   6:main.c        **** 
   7:main.c        **** #include "./include.h"
   8:main.c        **** 
   9:main.c        **** int main(void)
  10:main.c        **** {
 1311               		.loc 6 10 0
 1312 05f2 CF93      		push r28
 1313               	.LCFI34:
 1314 05f4 DF93      		push r29
 1315               	.LCFI35:
 1316 05f6 00D0      		rcall .
 1317               	.LCFI36:
 1318 05f8 CDB7      		in r28,__SP_L__
 1319 05fa DEB7      		in r29,__SP_H__
 1320               	.LCFI37:
 1321               	/* prologue: function */
 1322               	/* frame size = 2 */
 1323               	/* stack size = 4 */
 1324               	.L__stack_usage = 4
  11:main.c        **** 	/* DATA BUS INPUT OUTPUT DECLARATION */
  12:main.c        **** 	DDRB = 0xFF;		// 1	FAN
 1325               		.loc 6 12 0
 1326 05fc 8FEF      		ldi r24,lo8(-1)
 1327 05fe 87BB      		out 0x17,r24
  13:main.c        **** 						// 2	DATA	A->R
  14:main.c        **** 						// 3	CLOCK	A->R
  15:main.c        **** 						// 6	XTAL1
  16:main.c        **** 						// 7	XTAL2
  17:main.c        **** 	
  18:main.c        **** 	DDRB &= ~(1<<0);	// 0	DATA	R->A
 1328               		.loc 6 18 0
 1329 0600 B898      		cbi 0x17,0
  19:main.c        **** 	DDRB &= ~(1<<4);	// 4	CLOCK	R->A
 1330               		.loc 6 19 0
 1331 0602 BC98      		cbi 0x17,4
  20:main.c        **** 	DDRB &= ~(1<<5);	// 5	EXTRA	R->A
 1332               		.loc 6 20 0
 1333 0604 BD98      		cbi 0x17,5
  21:main.c        **** 	
  22:main.c        **** 	/* MOTOR INPUT OUTPUT DECLARATION */
  23:main.c        **** 	DDRD = 0xFF;		// 0	ENABLE
 1334               		.loc 6 23 0
 1335 0606 81BB      		out 0x11,r24
  24:main.c        **** 						// 1	DIR		LEFT
  25:main.c        **** 						// 2	DIR		RIGHT
  26:main.c        **** 						// 3	CLOCK	LEFT
  27:main.c        **** 						// 4	CLOCK	RIGHT
  28:main.c        **** 						// 5	PIEZO
  29:main.c        **** 						// 6	Not Connected
  30:main.c        **** 						// 7	Not Connected
  31:main.c        **** 	
  32:main.c        **** 	/* ENABLE FAN PWM */
  33:main.c        **** 	TCCR1A = (1<<COM1A1) | (1<<WGM10) | (1<<WGM11);
 1336               		.loc 6 33 0
 1337 0608 83E8      		ldi r24,lo8(-125)
 1338 060a 8FBD      		out 0x2f,r24
  34:main.c        **** 	TCCR1B = (1<<WGM12) | (1<<CS12);
 1339               		.loc 6 34 0
 1340 060c 8CE0      		ldi r24,lo8(12)
 1341 060e 8EBD      		out 0x2e,r24
  35:main.c        **** 	OCR1A = 255;
 1342               		.loc 6 35 0
 1343 0610 8FEF      		ldi r24,lo8(-1)
 1344 0612 90E0      		ldi r25,0
 1345 0614 9BBD      		out 0x2a+1,r25
 1346 0616 8ABD      		out 0x2a,r24
  36:main.c        **** 	
  37:main.c        **** 	/* DISABLE MOTORS BY DEFAULT */
  38:main.c        **** 	PORTD |= (1<<MOTOR_ENABLE);
 1347               		.loc 6 38 0
 1348 0618 909A      		sbi 0x12,0
  39:main.c        **** 	
  40:main.c        **** 	/* INDICATE STARTUP FINISH */
  41:main.c        **** 	beep(1500,50);
 1349               		.loc 6 41 0
 1350 061a 22E3      		ldi r18,lo8(50)
 1351 061c 30E0      		ldi r19,0
 1352 061e 40E0      		ldi r20,0
 1353 0620 50E0      		ldi r21,0
 1354 0622 6CED      		ldi r22,lo8(-36)
 1355 0624 75E0      		ldi r23,lo8(5)
 1356 0626 80E0      		ldi r24,0
 1357 0628 90E0      		ldi r25,0
 1358 062a 00D0      		rcall beep
 1359               	.LVL133:
 1360               	.LBB110:
  42:main.c        **** 	
  43:main.c        **** 	while(1)
  44:main.c        **** 	{
  45:main.c        **** 		char byte = dataBusRead();
  46:main.c        **** 		switch(byte)
 1361               		.loc 6 46 0
 1362 062c A12C      		mov r10,__zero_reg__
 1363 062e B12C      		mov r11,__zero_reg__
 1364               	.LBB111:
 1365               	.LBB112:
  47:main.c        **** 		{
  48:main.c        **** 			case 1:
  49:main.c        **** 			{
  50:main.c        **** 				int failure = 0;
  51:main.c        **** 				for(int i = 0; i < 100; i++)
 1366               		.loc 6 51 0
 1367 0630 00E0      		ldi r16,0
 1368               	.L110:
 1369               	.LBE112:
 1370               	.LBE111:
  45:main.c        **** 		char byte = dataBusRead();
 1371               		.loc 6 45 0
 1372 0632 00D0      		rcall dataBusRead
 1373               	.LVL134:
  46:main.c        **** 		switch(byte)
 1374               		.loc 6 46 0
 1375 0634 8430      		cpi r24,lo8(4)
 1376 0636 01F4      		brne .+2
 1377 0638 00C0      		rjmp .L97
 1378 063a 00F4      		brsh .L100
 1379 063c 8130      		cpi r24,lo8(1)
 1380 063e 01F0      		breq .L106
 1381 0640 8330      		cpi r24,lo8(3)
 1382 0642 01F4      		brne .L110
 1383 0644 00C0      		rjmp .L96
 1384               	.L100:
 1385 0646 8530      		cpi r24,lo8(5)
 1386 0648 01F4      		brne .+2
 1387 064a 00C0      		rjmp .L98
 1388 064c 8630      		cpi r24,lo8(6)
 1389 064e 01F4      		brne .L110
 1390 0650 00C0      		rjmp .L99
 1391               	.L106:
 1392 0652 6501      		movw r12,r10
 1393 0654 7501      		movw r14,r10
 1394               	.LVL135:
 1395               	.L95:
 1396               	.LBB117:
 1397               	.LBB113:
  52:main.c        **** 				{
  53:main.c        **** 					if(dataBusRead() != i)
 1398               		.loc 6 53 0
 1399 0656 00D0      		rcall dataBusRead
 1400               	.LVL136:
 1401 0658 90E0      		ldi r25,0
 1402 065a 8C15      		cp r24,r12
 1403 065c 9D05      		cpc r25,r13
 1404 065e 01F0      		breq .L101
  54:main.c        **** 						failure = 1;
 1405               		.loc 6 54 0
 1406 0660 EE24      		clr r14
 1407 0662 E394      		inc r14
 1408 0664 F12C      		mov r15,__zero_reg__
 1409               	.L101:
 1410               	.LVL137:
  51:main.c        **** 				for(int i = 0; i < 100; i++)
 1411               		.loc 6 51 0
 1412 0666 2FEF      		ldi r18,-1
 1413 0668 C21A      		sub r12,r18
 1414 066a D20A      		sbc r13,r18
 1415               	.LVL138:
 1416 066c 34E6      		ldi r19,100
 1417 066e C316      		cp r12,r19
 1418 0670 D104      		cpc r13,__zero_reg__
 1419 0672 01F4      		brne .L95
 1420               	.LVL139:
  51:main.c        **** 				for(int i = 0; i < 100; i++)
 1421               		.loc 6 51 0 is_stmt 0 discriminator 1
 1422 0674 102F      		mov r17,r16
 1423               	.LVL140:
 1424               	.L102:
 1425               	.LBE113:
 1426               	.LBB114:
  55:main.c        **** 				}
  56:main.c        **** 				for(int i = 0; i < 100; i++)
  57:main.c        **** 				{
  58:main.c        **** 					dataBusSend(i);
 1427               		.loc 6 58 0 is_stmt 1 discriminator 2
 1428 0676 812F      		mov r24,r17
 1429 0678 00D0      		rcall dataBusSend
 1430               	.LVL141:
 1431 067a 1F5F      		subi r17,lo8(-(1))
  56:main.c        **** 				for(int i = 0; i < 100; i++)
 1432               		.loc 6 56 0 discriminator 2
 1433 067c 1436      		cpi r17,lo8(100)
 1434 067e 01F4      		brne .L102
 1435               	.LVL142:
 1436               	.LBE114:
 1437               	.LBB115:
 1438               	.LBB116:
 164:/usr/lib/gcc/avr/4.7.2/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1439               		.loc 2 164 0
 1440 0680 8FEF      		ldi r24,lo8(159999)
 1441 0682 90E7      		ldi r25,hi8(159999)
 1442 0684 E2E0      		ldi r30,hlo8(159999)
 1443 0686 8150      		1: subi r24,1
 1444 0688 9040      		sbci r25,0
 1445 068a E040      		sbci r30,0
 1446 068c 01F4      		brne 1b
 1447 068e 00C0      		rjmp .
 1448 0690 0000      		nop
 1449               	.LBE116:
 1450               	.LBE115:
  59:main.c        **** 				}
  60:main.c        **** 				_delay_ms(50);
  61:main.c        **** 				if(failure == 0)
 1451               		.loc 6 61 0
 1452 0692 EF28      		or r14,r15
 1453 0694 01F4      		brne .L103
  62:main.c        **** 					dataBusSend(1);
 1454               		.loc 6 62 0
 1455 0696 81E0      		ldi r24,lo8(1)
 1456 0698 00D0      		rcall dataBusSend
 1457               	.LVL143:
 1458 069a 00C0      		rjmp .L110
 1459               	.L103:
  63:main.c        **** 				else
  64:main.c        **** 					dataBusSend(0);
 1460               		.loc 6 64 0
 1461 069c 802F      		mov r24,r16
 1462 069e 00D0      		rcall dataBusSend
 1463               	.LVL144:
 1464 06a0 00C0      		rjmp .L110
 1465               	.LVL145:
 1466               	.L96:
 1467               	.LBE117:
  65:main.c        **** 				break;
  66:main.c        **** 			}
  67:main.c        **** 			case 3:
  68:main.c        **** 			{
  69:main.c        **** 				OCR1A = (int)(((float)dataBusRead() / 100.0) * 1023.0);
 1468               		.loc 6 69 0
 1469 06a2 00D0      		rcall dataBusRead
 1470               	.LVL146:
 1471 06a4 682F      		mov r22,r24
 1472 06a6 70E0      		ldi r23,0
 1473 06a8 80E0      		ldi r24,0
 1474 06aa 90E0      		ldi r25,0
 1475 06ac 00D0      		rcall __floatunsisf
 1476               	.LVL147:
 1477 06ae 20E0      		ldi r18,0
 1478 06b0 30E0      		ldi r19,0
 1479 06b2 48EC      		ldi r20,lo8(-56)
 1480 06b4 52E4      		ldi r21,lo8(66)
 1481 06b6 00D0      		rcall __divsf3
 1482               	.LVL148:
 1483 06b8 20E0      		ldi r18,0
 1484 06ba 30EC      		ldi r19,lo8(-64)
 1485 06bc 4FE7      		ldi r20,lo8(127)
 1486 06be 54E4      		ldi r21,lo8(68)
 1487 06c0 00D0      		rcall __mulsf3
 1488               	.LVL149:
 1489 06c2 00D0      		rcall __fixsfsi
 1490               	.LVL150:
 1491 06c4 7BBD      		out 0x2a+1,r23
 1492 06c6 6ABD      		out 0x2a,r22
  70:main.c        **** 				dataBusSend(1);
 1493               		.loc 6 70 0
 1494 06c8 81E0      		ldi r24,lo8(1)
 1495 06ca 00D0      		rcall dataBusSend
 1496               	.LVL151:
  71:main.c        **** 				break;
 1497               		.loc 6 71 0
 1498 06cc 00C0      		rjmp .L110
 1499               	.LVL152:
 1500               	.L97:
  72:main.c        **** 			}
  73:main.c        **** 			case 4:
  74:main.c        **** 			{
  75:main.c        **** 				byte = dataBusRead();
 1501               		.loc 6 75 0
 1502 06ce 00D0      		rcall dataBusRead
 1503               	.LVL153:
  76:main.c        **** 				if(byte == 0)
 1504               		.loc 6 76 0
 1505 06d0 8111      		cpse r24,__zero_reg__
 1506 06d2 00C0      		rjmp .L105
  77:main.c        **** 				{
  78:main.c        **** 					PORTD |= (1<<0);
 1507               		.loc 6 78 0
 1508 06d4 909A      		sbi 0x12,0
  79:main.c        **** 					dataBusSend(0);
 1509               		.loc 6 79 0
 1510 06d6 802F      		mov r24,r16
 1511               	.LVL154:
 1512 06d8 00D0      		rcall dataBusSend
 1513               	.LVL155:
 1514 06da 00C0      		rjmp .L110
 1515               	.LVL156:
 1516               	.L105:
  80:main.c        **** 				}
  81:main.c        **** 				else
  82:main.c        **** 				{
  83:main.c        **** 					PORTD &= ~(1<<0);
 1517               		.loc 6 83 0
 1518 06dc 9098      		cbi 0x12,0
  84:main.c        **** 					dataBusSend(1);
 1519               		.loc 6 84 0
 1520 06de 81E0      		ldi r24,lo8(1)
 1521               	.LVL157:
 1522 06e0 00D0      		rcall dataBusSend
 1523               	.LVL158:
 1524 06e2 00C0      		rjmp .L110
 1525               	.LVL159:
 1526               	.L98:
 1527               	.LBB118:
  85:main.c        **** 				}
  86:main.c        **** 				break;
  87:main.c        **** 			}
  88:main.c        **** 			case 5:
  89:main.c        **** 			{
  90:main.c        **** 				uint32_t steps = 0;
  91:main.c        **** 				char leftDir = 0;
  92:main.c        **** 				char rightDir = 0;
  93:main.c        **** 				steps = dataBusRead();
 1528               		.loc 6 93 0
 1529 06e4 00D0      		rcall dataBusRead
 1530               	.LVL160:
 1531 06e6 C82E      		mov r12,r24
 1532 06e8 D12C      		mov r13,__zero_reg__
 1533 06ea E12C      		mov r14,__zero_reg__
 1534 06ec F12C      		mov r15,__zero_reg__
 1535               	.LVL161:
  94:main.c        **** 				steps += (dataBusRead()<<8);
 1536               		.loc 6 94 0
 1537 06ee 00D0      		rcall dataBusRead
 1538               	.LVL162:
 1539 06f0 382E      		mov r3,r24
 1540 06f2 212C      		mov r2,__zero_reg__
 1541 06f4 C101      		movw r24,r2
 1542 06f6 AA27      		clr r26
 1543 06f8 97FD      		sbrc r25,7
 1544 06fa A095      		com r26
 1545 06fc BA2F      		mov r27,r26
 1546 06fe C80E      		add r12,r24
 1547 0700 D91E      		adc r13,r25
 1548 0702 EA1E      		adc r14,r26
 1549 0704 FB1E      		adc r15,r27
 1550               	.LVL163:
  95:main.c        **** 				steps += (dataBusRead()<<16);
 1551               		.loc 6 95 0
 1552 0706 00D0      		rcall dataBusRead
 1553               	.LVL164:
  96:main.c        **** 				steps += (dataBusRead()<<24);
 1554               		.loc 6 96 0
 1555 0708 00D0      		rcall dataBusRead
 1556               	.LVL165:
  97:main.c        **** 				leftDir = dataBusRead();
 1557               		.loc 6 97 0
 1558 070a 00D0      		rcall dataBusRead
 1559               	.LVL166:
 1560 070c 782E      		mov r7,r24
 1561               	.LVL167:
  98:main.c        **** 				rightDir = dataBusRead();
 1562               		.loc 6 98 0
 1563 070e 00D0      		rcall dataBusRead
 1564               	.LVL168:
  99:main.c        **** 				drive(steps,leftDir,rightDir);
 1565               		.loc 6 99 0
 1566 0710 282F      		mov r18,r24
 1567 0712 472D      		mov r20,r7
 1568 0714 C701      		movw r24,r14
 1569 0716 B601      		movw r22,r12
 1570 0718 00D0      		rcall drive
 1571               	.LVL169:
 100:main.c        **** 				dataBusSend(1);
 1572               		.loc 6 100 0
 1573 071a 81E0      		ldi r24,lo8(1)
 1574 071c 00D0      		rcall dataBusSend
 1575               	.LVL170:
 101:main.c        **** 				break;
 1576               		.loc 6 101 0
 1577 071e 00C0      		rjmp .L110
 1578               	.LVL171:
 1579               	.L99:
 1580               	.LBE118:
 1581               	.LBB119:
 102:main.c        **** 			}
 103:main.c        **** 			case 6:
 104:main.c        **** 			{
 105:main.c        **** 				uint32_t frequency = 0;
 106:main.c        **** 				uint32_t duration = 0;
 107:main.c        **** 				frequency = dataBusRead();
 1582               		.loc 6 107 0
 1583 0720 00D0      		rcall dataBusRead
 1584               	.LVL172:
 1585 0722 482E      		mov r4,r24
 1586 0724 512C      		mov r5,__zero_reg__
 1587 0726 612C      		mov r6,__zero_reg__
 1588 0728 712C      		mov r7,__zero_reg__
 1589               	.LVL173:
 108:main.c        **** 				frequency += (dataBusRead()<<8);
 1590               		.loc 6 108 0
 1591 072a 00D0      		rcall dataBusRead
 1592               	.LVL174:
 1593 072c 982E      		mov r9,r24
 1594 072e 812C      		mov r8,__zero_reg__
 1595 0730 C401      		movw r24,r8
 1596 0732 AA27      		clr r26
 1597 0734 97FD      		sbrc r25,7
 1598 0736 A095      		com r26
 1599 0738 BA2F      		mov r27,r26
 1600 073a 480E      		add r4,r24
 1601 073c 591E      		adc r5,r25
 1602 073e 6A1E      		adc r6,r26
 1603 0740 7B1E      		adc r7,r27
 1604               	.LVL175:
 109:main.c        **** 				frequency += (dataBusRead()<<16);
 1605               		.loc 6 109 0
 1606 0742 00D0      		rcall dataBusRead
 1607               	.LVL176:
 110:main.c        **** 				frequency += (dataBusRead()<<24);
 1608               		.loc 6 110 0
 1609 0744 00D0      		rcall dataBusRead
 1610               	.LVL177:
 111:main.c        **** 				duration = dataBusRead();
 1611               		.loc 6 111 0
 1612 0746 00D0      		rcall dataBusRead
 1613               	.LVL178:
 1614 0748 C82E      		mov r12,r24
 1615 074a D12C      		mov r13,__zero_reg__
 1616 074c E12C      		mov r14,__zero_reg__
 1617 074e F12C      		mov r15,__zero_reg__
 1618               	.LVL179:
 112:main.c        **** 				duration += (dataBusRead()<<8);
 1619               		.loc 6 112 0
 1620 0750 00D0      		rcall dataBusRead
 1621               	.LVL180:
 1622 0752 8A83      		std Y+2,r24
 1623 0754 1982      		std Y+1,__zero_reg__
 1624 0756 2981      		ldd r18,Y+1
 1625 0758 3A81      		ldd r19,Y+2
 1626 075a C901      		movw r24,r18
 1627 075c AA27      		clr r26
 1628 075e 97FD      		sbrc r25,7
 1629 0760 A095      		com r26
 1630 0762 BA2F      		mov r27,r26
 1631 0764 C80E      		add r12,r24
 1632 0766 D91E      		adc r13,r25
 1633 0768 EA1E      		adc r14,r26
 1634 076a FB1E      		adc r15,r27
 1635               	.LVL181:
 113:main.c        **** 				duration += (dataBusRead()<<16);
 1636               		.loc 6 113 0
 1637 076c 00D0      		rcall dataBusRead
 1638               	.LVL182:
 114:main.c        **** 				duration += (dataBusRead()<<24);
 1639               		.loc 6 114 0
 1640 076e 00D0      		rcall dataBusRead
 1641               	.LVL183:
 115:main.c        **** 				beep(frequency,duration);
 1642               		.loc 6 115 0
 1643 0770 A701      		movw r20,r14
 1644 0772 9601      		movw r18,r12
 1645 0774 C301      		movw r24,r6
 1646 0776 B201      		movw r22,r4
 1647 0778 00D0      		rcall beep
 1648               	.LVL184:
 116:main.c        **** 				dataBusSend(1);
 1649               		.loc 6 116 0
 1650 077a 81E0      		ldi r24,lo8(1)
 1651 077c 00D0      		rcall dataBusSend
 1652               	.LVL185:
 117:main.c        **** 				break;
 1653               		.loc 6 117 0
 1654 077e 00C0      		rjmp .L110
 1655               	.LBE119:
 1656               	.LBE110:
 1657               	.LFE14:
 1965               	.Letext0:
 1966               		.file 7 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/stdint.h"
 1967               		.file 8 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/stdio.h"
 1968               		.file 9 "/usr/lib/gcc/avr/4.7.2/../../../avr/include/math.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/cctJpV4n.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cctJpV4n.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cctJpV4n.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cctJpV4n.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cctJpV4n.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cctJpV4n.s:16     .text:0000000000000000 drive
     /tmp/cctJpV4n.s:828    .text:000000000000040e usart_putChar
     /tmp/cctJpV4n.s:862    .text:0000000000000426 usart_getChar
     /tmp/cctJpV4n.s:884    .text:0000000000000430 usart_init
     /tmp/cctJpV4n.s:919    .text:000000000000044c dataBusRead
     /tmp/cctJpV4n.s:992    .text:0000000000000492 dataBusSend
     /tmp/cctJpV4n.s:1083   .text:00000000000004e4 beep
     /tmp/cctJpV4n.s:1308   .text:00000000000005f2 main

UNDEFINED SYMBOLS
__floatsisf
__subsf3
__mulsf3
__ltsf2
__gtsf2
sqrt
__floatunsisf
__divsf3
__udivmodsi4
__fixsfsi
